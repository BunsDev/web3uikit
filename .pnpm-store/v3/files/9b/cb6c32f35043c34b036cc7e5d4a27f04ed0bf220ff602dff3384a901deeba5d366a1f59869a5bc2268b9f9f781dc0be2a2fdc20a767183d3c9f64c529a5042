"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginConfig = exports.commonConfig = exports.readPackageJson = void 0;
const path = __importStar(require("path"));
const fs_1 = __importDefault(require("fs"));
const envs_1 = require("./envs");
const mock_core_js_1 = require("./mock-core-js");
const code_generator_plugin_1 = require("./code-generator-plugin");
const inject_export_order_plugin_1 = require("./inject-export-order-plugin");
const mdx_plugin_1 = require("./mdx-plugin");
const no_fouc_1 = require("./plugins/no-fouc");
const source_loader_plugin_1 = require("./source-loader-plugin");
function readPackageJson() {
    const packageJsonPath = path.resolve('package.json');
    if (!fs_1.default.existsSync(packageJsonPath)) {
        return false;
    }
    const jsonContent = fs_1.default.readFileSync(packageJsonPath, 'utf8');
    return JSON.parse(jsonContent);
}
exports.readPackageJson = readPackageJson;
// Vite config that is common to development and production mode
async function commonConfig(options, _type) {
    const { framework } = options;
    return {
        configFile: false,
        root: path.resolve(options.configDir, '..'),
        cacheDir: 'node_modules/.vite-storybook',
        envPrefix: envs_1.allowedEnvPrefix,
        define: {},
        resolve: framework === 'vue3'
            ? {
                alias: {
                    vue: 'vue/dist/vue.esm-bundler.js',
                },
            }
            : {},
        plugins: await pluginConfig(options, _type),
    };
}
exports.commonConfig = commonConfig;
async function pluginConfig(options, _type) {
    var _a, _b;
    const { framework, presets } = options;
    const svelteOptions = await presets.apply('svelteOptions', {}, options);
    const plugins = [
        (0, code_generator_plugin_1.codeGeneratorPlugin)(options),
        (0, mock_core_js_1.mockCoreJs)(),
        (0, source_loader_plugin_1.sourceLoaderPlugin)(options),
        (0, mdx_plugin_1.mdxPlugin)(),
        (0, no_fouc_1.noFouc)(),
        inject_export_order_plugin_1.injectExportOrderPlugin,
    ];
    if (framework === 'vue' || framework === 'vue3') {
        try {
            const vuePlugin = require('@vitejs/plugin-vue');
            plugins.push(vuePlugin());
            const { vueDocgen } = await Promise.resolve().then(() => __importStar(require('./plugins/vue-docgen')));
            plugins.push(vueDocgen());
        }
        catch (err) {
            if (err.code === 'MODULE_NOT_FOUND') {
                throw new Error('@storybook/builder-vite requires @vitejs/plugin-vue to be installed ' +
                    'when using @storybook/vue or @storybook/vue3.' +
                    '  Please install it and start storybook again.');
            }
            throw err;
        }
    }
    if (framework === 'svelte') {
        try {
            const sveltePlugin = require('@sveltejs/vite-plugin-svelte').svelte;
            // We need to create two separate svelte plugins, one for stories, and one for other svelte files
            // because stories.svelte files cannot be hot-module-reloaded.
            // Suggested in: https://github.com/sveltejs/vite-plugin-svelte/issues/321#issuecomment-1113205509
            // First, create an array containing user exclude patterns, to combine with ours.
            const userExclude = Array.isArray(svelteOptions === null || svelteOptions === void 0 ? void 0 : svelteOptions.exclude)
                ? svelteOptions === null || svelteOptions === void 0 ? void 0 : svelteOptions.exclude
                : (svelteOptions === null || svelteOptions === void 0 ? void 0 : svelteOptions.exclude)
                    ? [svelteOptions === null || svelteOptions === void 0 ? void 0 : svelteOptions.exclude]
                    : [];
            // These are the svelte stories we need to exclude from HMR
            const storyPatterns = ['**/*.story.svelte', '**/*.stories.svelte'];
            // Non-story svelte files
            // Starting in 1.0.0-next.42, svelte.config.js is included by default.
            // We disable that, but allow it to be overridden in svelteOptions
            plugins.push(sveltePlugin({ configFile: false, ...svelteOptions, exclude: [...userExclude, ...storyPatterns] }));
            // Svelte stories without HMR
            const storySveltePlugin = sveltePlugin({
                configFile: false,
                ...svelteOptions,
                exclude: userExclude,
                include: storyPatterns,
                hot: false,
            });
            plugins.push({
                // Starting in 1.0.0-next.43, the plugin function returns an array of plugins.  We only want the first one here.
                ...(Array.isArray(storySveltePlugin) ? storySveltePlugin[0] : storySveltePlugin),
                name: 'vite-plugin-svelte-stories',
            });
        }
        catch (err) {
            if (err.code === 'MODULE_NOT_FOUND') {
                throw new Error('@storybook/builder-vite requires @sveltejs/vite-plugin-svelte to be installed' +
                    ' when using @storybook/svelte.' +
                    '  Please install it and start storybook again.');
            }
            throw err;
        }
        try {
            const csfPlugin = require('./svelte/csf-plugin').default;
            plugins.push(csfPlugin(svelteOptions));
        }
        catch (err) {
            // Not all projects use `.stories.svelte` for stories, and by default 6.5+ does not auto-install @storybook/addon-svelte-csf.
            // If it's any other kind of error, re-throw.
            if (err.code !== 'MODULE_NOT_FOUND') {
                throw err;
            }
        }
        const { svelteDocgen } = await Promise.resolve().then(() => __importStar(require('./plugins/svelte-docgen')));
        plugins.push(svelteDocgen(svelteOptions));
    }
    if (framework === 'react') {
        plugins.push(require('@vitejs/plugin-react')({
            // Do not treat story files as HMR boundaries, storybook itself needs to handle them.
            exclude: [/\.stories\.([tj])sx?$/, /node_modules/],
        }));
        const { reactDocgen, reactDocgenTypescriptOptions } = await presets.apply('typescript', {});
        let typescriptPresent;
        try {
            const pkgJson = readPackageJson();
            typescriptPresent = pkgJson && (((_a = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.devDependencies) === null || _a === void 0 ? void 0 : _a.typescript) || ((_b = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.dependencies) === null || _b === void 0 ? void 0 : _b.typescript));
        }
        catch (e) {
            typescriptPresent = false;
        }
        if (reactDocgen === 'react-docgen-typescript' && typescriptPresent) {
            plugins.push(require('@joshwooding/vite-plugin-react-docgen-typescript').default(reactDocgenTypescriptOptions));
        }
        else if (reactDocgen) {
            const { reactDocgen } = await Promise.resolve().then(() => __importStar(require('./plugins/react-docgen')));
            // Needs to run before the react plugin, so add to the front
            plugins.unshift(reactDocgen());
        }
    }
    if (framework === 'glimmerx') {
        const plugin = require('vite-plugin-glimmerx/index.cjs');
        plugins.push(plugin.default());
    }
    return plugins;
}
exports.pluginConfig = pluginConfig;
//# sourceMappingURL=vite-config.js.map